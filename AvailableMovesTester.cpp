// AvailableMovesTester - program to diagnose broken generation of
// available moves.
//
// Use this program after a change has caused the number of moves 
// required to solve a deal to increase incorrectly, so a version that
// generates correct results is still available.
//
// Build this program with the corrupted code.
// 
// Input:
//      1.  On standard input, a one-line file containing the move sequence
//          generated by solving the deal using an uncorrupted version of 
//          KSolve with the -O 2 and -mvs options.
//      2.  The deal, specified by the command line option -ran <number>.
//          Other ways of entering the deal can be adapted from KSolve.cpp.
// Output:
//      1.  The input string, followed by the initial part of the input
//          string that matches the input string.  The first missing
//          part of the initial string was not found to be available
//          by the corrupted code.
//      2.  The game state after the last matching move has been made.

#include <string>
#include <vector>
#include <iostream>
#include "Game.hpp"

using namespace std;
using namespace KSolveNames;

using StringVec = vector<string>;

static StringVec GetArguments(int argc, char* argv[])
{
    StringVec result;
    for (unsigned j = 1; j < argc; ++j) {
        result.push_back(argv[j]);
    }
    return result;
}
static unsigned GetNumber(string s)
{
    size_t charsConverted;
    unsigned result = stoul(s, &charsConverted);
    assert(charsConverted == s.size() && "invalid data follows -ran");
    return result;
}
static CardDeck GetDeal(StringVec args){
    // expecting "-ran <number>"
    assert (args.size() == 2);
    assert (args[0] == "-ran");
    unsigned dealNum {GetNumber(args[1])};

    CardDeck result = NumberedDeal(dealNum);
    return result;
}
static string GetSolutionString()
{
    char line[1000];
    cin.getline(line,sizeof(line));
    return string(line);
}
// Lifted whole from KSolve.cpp's MovesMade()
static string MovesMadeX(const XMoves& moves)
{
    stringstream ss;
    char PileNames[] {"W1234567?CDSH"};
    for (XMove mv: moves) {
        if (mv.To() == Stock) ss << "NEW ";
        else if (mv.From() == Stock) ss << "DR" << mv.NCards() << " ";
        else {
            ss << PileNames[mv.From()] << PileNames[mv.To()];
            if (mv.NCards() > 1) ss << "-" << mv.NCards();
            ss << " ";
            if (mv.Flip()) ss << "F" << PileNames[mv.From()] << " ";
        }
    }
    return ss.str();
}
static string MovesMadeStr(const Moves& movesMade, const Game& game)
{
    XMoves xMovesMade = MakeXMoves(movesMade,game.DrawSetting());
    return MovesMadeX(xMovesMade);
}
static void PrintErrorReport(const Game& game, const Moves& movesMade, const string& solStr)
{
    cout << "Input: " << solStr << '\n';
    cout << "Match: " << MovesMadeStr(movesMade, game) << "\n";
    cout << "movesMade.size() = " << movesMade.size() << "\n";
    cout << Peek(game);

}

int main (int argc, char* argv[])
{
    auto arguments = GetArguments(argc,argv);
    CardDeck deal = GetDeal(arguments);
    string solStr = GetSolutionString();

    Game game{deal, 1};

    string trialSolStr;
    Moves movesMade;
    QMoves avail;
    XMoves xMovesMade;

    while(trialSolStr.size() < solStr.size()) {
        avail = game.AvailableMoves(movesMade);
        bool match{false};
        for (auto mv:avail) {
            movesMade.push_back(mv);
            if (solStr.starts_with(MovesMadeStr(movesMade,game))) {
                game.MakeMove(mv);
                match = true;
                break;
                // next move in the solution found in avail.
            } else {
                movesMade.pop_back();
            }
        }
        // The next move in the solution was not found in avail. 
        if (!match) {
            PrintErrorReport(game, movesMade, solStr);
            return 8;
        }
    }
    // All the moves in solStr were generated in sequence.
    assert(game.GameOver());
    cout << "No problems found." << endl;
}
